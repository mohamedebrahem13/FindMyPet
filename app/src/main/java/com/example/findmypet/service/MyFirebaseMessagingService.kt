package com.example.findmypet.service

import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.drawable.Drawable
import android.os.Build
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.core.app.NotificationCompat
import com.bumptech.glide.Glide
import com.bumptech.glide.request.target.CustomTarget
import com.bumptech.glide.request.transition.Transition
import com.example.findmypet.R
import com.example.findmypet.activities.MainActivity
import com.example.findmypet.common.Constant
import com.example.findmypet.data.repository.FirebaseAuthenticator
import com.google.firebase.messaging.FirebaseMessagingService
import com.google.firebase.messaging.RemoteMessage
import dagger.hilt.android.AndroidEntryPoint
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import javax.inject.Inject

@AndroidEntryPoint
class MyFirebaseMessagingService : FirebaseMessagingService() {

    @Inject
    lateinit var authenticator: FirebaseAuthenticator
    @RequiresApi(Build.VERSION_CODES.S)
    override fun onMessageReceived(remoteMessage: RemoteMessage) {
        super.onMessageReceived(remoteMessage)

        remoteMessage.from?.let { from ->
            Log.d("GET_NOTIFICATION", "Received message from: $from")

            val notification = remoteMessage.notification
            val title = notification?.title ?: "Default Title"
            val body = notification?.body ?: "Default Body"
            val imageUrl = notification?.imageUrl ?: "Default imageUrl"
            Log.d("Notification", "Received imageUrl: $imageUrl")

            // Determine the channel ID based on the message source
            val channelId = when {
                from.contains("/topics/new_pet") -> Constant.PET_CHANNEL_ID
                else -> Constant.CHAT_CHANNEL_ID
            }

            Log.d("NotificationChannel", " channel ID: $channelId")
            createNotification(title, body, imageUrl.toString(), channelId)
        }
    }

    override fun onNewToken(token: String) {
        super.onNewToken(token)
        // Update the token whenever a new one is generated by FCM
        Log.d("FCM_TOKEN", "Refreshed token: $token")

        // Check if authenticator is initialized
        if (::authenticator.isInitialized) {
            CoroutineScope(Dispatchers.IO).launch {
                try {
                    authenticator.updateTokenForCurrentUser(token)
                } catch (e: Exception) {
                    Log.e("FCM_TOKEN", "Error updating token: ${e.message}")
                }
            }
        } else {
            Log.e("FCM_TOKEN", "Authenticator is not initialized")
        }

    }

    private fun createNotification(title: String, body: String, imageUrl: String, channelId: String) {
        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        val intent = Intent(this, MainActivity::class.java)
        val pendingIntent = PendingIntent.getActivity(
            this,
            0,
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE
        )

        // Prepare notification builder
        val notificationBuilder = NotificationCompat.Builder(this, channelId)
            .setContentTitle(title)
            .setContentText(body)
            .setSmallIcon(R.drawable.find_my_pet_lc)
            .setContentIntent(pendingIntent)
            .setAutoCancel(true)

        // Load and set image using Glide
        if (imageUrl.isNotBlank()) {
            Glide.with(this)
                .asBitmap()
                .load(imageUrl)
                .into(object : CustomTarget<Bitmap>() {
                    override fun onResourceReady(resource: Bitmap, transition: Transition<in Bitmap>?) {
                        notificationBuilder.setStyle(NotificationCompat.BigPictureStyle()
                            .bigPicture(resource))
                        // Build and show the notification with the image
                        val notification = notificationBuilder.build()
                        val uniqueNotificationId = System.currentTimeMillis().toInt()
                        notificationManager.notify(uniqueNotificationId, notification)
                    }

                    override fun onLoadCleared(placeholder: Drawable?) {
                        // Handle cleanup if necessary
                    }
                })
        } else {
            // Build and show the notification without an image
            val notification = notificationBuilder.build()
            val uniqueNotificationId = System.currentTimeMillis().toInt()
            notificationManager.notify(uniqueNotificationId, notification)
        }
    }

}
